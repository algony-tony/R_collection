---
title: "R基础"
output: html_document
---

# 基础
在交互环境下执行一个 R 文件  
```
source("z.R")  
```
在批处理环境下执行  
```
R CMD BATCH z.R
```
将原本在终端输出的结果转存到文件record.lis中 sink("record.lis")，重新将结果输出到终端 sink().

## R 的启动
R 每次启动都会先在执行目录下寻找 .Rprofile 文件, 而后在用户 home 目录下寻找该文件. 可以将每次启用要执行的命令放在该文件里.
.Rdata 记录 session 所存下来的数据;
.Rhistory 记录 session 的命令历史;
R操作的都是对象object，当前所存储的对象的集合叫做工作区workspace.

class() 查看对象的类名;
attributes() 查看对象的所有属性值;

require() 在函数内使用，当包未找到是报出warning，并继续执行，而library() 则会抛出error.

启动 R 时用参数 vanilla 将不会加载任何配置文件(包含.Rprofile, .Rdata等)
```
R --vanilla
```
进一步查看  ?Startup

## R 帮助文档
特殊字符的帮助命令用双引号  ?"for"  ?"<"
example() 函数会自动执行帮助文档最后的例子
```
example(seq)
example(persp)
```

显示某个包的简短描述以及包中的函数名称和数据集名称的列表
help(package="package_name")
```
help.search("search word")
```

查看运算符号优先级用:
?Syntax

## NA vs NULL
在 R 中, **NA** 代表对象缺失(missing data), **NULL** 代表对象不存在(doesn't exist, rather than being existent but unknown).
```{r}
x <- c(1, NULL, 4)
length(x)
x <- c(1, NA, 4)
length(x)
```

filter时用 subset() 将过滤 NA 值, which() 返回逻辑为 TRUE 的位置
```{r}
x <- c(6,1:3,NA,12)
x[x>5]
x[which(x>5)]
subset(x,x>5)
```

# Data Type 
**vector** 每个元素的mode（数据类型）要一致, 单个数字、字符串都是长度为 1 的向量.  
**matrix** 是附带了两个属性的向量，行数和列数.  
**list** 是不要求类型一致的 vector.  
**data frame** 是list，这种list每个元素都是一个向量，对应于data frame的一个列, data frame和数据库里的表类似.  

## Vector
R程序的 **向量化(vectorized)** 能极大提高效率.

vector 对应于 C 中的数组 array, 没有insert, delete操作, vector 运算长度不够时, 它会自动 recycling.

例:
```{r}
x <- c(88,5,12,13)
x <- c(x[1:3],168,x[4])
```
本质上这里的 x 是一个指针 pointer, 第二步将 x 指向新地址.

负号表示排除
```
x[-c(1,3)] 
```

若 y 没有事先生成, 直接如下面这样是会报错的, 这是因为 R 的函数是编程的特点, 关于向量元素的读写事实上是通过函数实现的, 若不事先知道 y 的类型, 该函数就无法操作.
```
y[1] <- 1
```

但是可以这样赋值
```{r}
y <- c(5,12)
y <- vector(length=2)
```

2+3 也可以写成如下
```{r}
"+"(2,3)
```

all() 和 any() 函数判断 all/any 所有的参数都是 True
```{r}
x <- 1:10
any(x>8)
#上面会先产生这样的逻辑向量(FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,TRUE), 然后返回 TRUE
```

判断两个向量是否相等
```
all(x==y)   #只判断值是否相等, 不检测类型
```
或者用 identical(x,y) 判断值和类型是否相等
```{r identical}
x <- 1:2
typeof(x)
y <- c(1,2)
typeof(y)
all(x==y)
identical(x,y)
```

ifelse(test,yes,no) 是向量化的 if-then-else 函数, yes 和 no 是向量, test 是逻辑向量, 返回的也是向量.


向量每个因素可以赋予名字
```{r}
x <- c(1,2,3)
names(x) <- c("a","b","dad")
# 删除向量的元素名字
names(x) <- NULL
```

c() 函数有将向量扁平化的作用, 下面两个相等.
```{r}
c(1,2,c(3,4))
c(1,2,3,4)
```

# Matrix & Array
matrices 是附带两个属性的 vector, array 是多维 vector;
```{r}
# 生成矩阵
y <- matrix(c(1:4), nrow=2, ncol=2, byrow=TRUE)
y

# 生成array
ay <- array(data=c(y,y),dim=c(3,2,2))
ay

# 矩阵转置
t(y)

# 矩阵乘法
y %*% y

# 矩阵对应元素乘积
y * y

# 返回最大值
max(y)

# 返回最大值所在的位置
which.max(y)

# 行列绑定
cbind(y,y)
rbind(y,y)

dim(y)

# 矩阵乘法, 下面两个表达式结果相等, 但是用crossprod函数更高效
crossprod(y,y)
t(y) %*% y

# 取对角线元素
diag(y)

# k阶单位矩阵
diag(5)

# 计算特征值和特征向量
eigen(y)

# 对于大型矩阵只需要计算特征值的时候可以加参数
eigen(y, only.values = T)$values

# 计算矩阵的逆
solve(y)

x <- 9:10
# 当需要计算 A^{-1} %*% x 时, 使用下面的形式更高效和稳定
solve(y, x)

```

在 R 里, 对矩阵只取一行或者一列后得到的是一个向量, 而不是一个矩阵,它会自动做一个维度约化(dimension reduction), 使用 drop=FALSE 可以强制不做维度约化.
```{r}
y <- matrix(c(1:4), nrow=2, ncol=2, byrow=TRUE)
class(y[1,])
class(y[1,, drop=FALSE])
```

[ 是一个函数
```{r}
# 下面等价于 y[2,1]
"["(y,2,1) 
```

可以给行列赋值
```{r}
colnames(y)
rownames(y)
colnames(y) <- c("c1", "c2")
rownames(y) <- c("r1", "r2")
colnames(y)
rownames(y)
```

# List
list 其实也是 vector, 是 recursive vector, 嵌套的vector.
```{r}
j <- list(name="Joe", salary=55000, union=T)
j
z <- vector(mode="list")
z[["abc"]] <- 3
z
```

list 的每个分支component 在 R 里叫 tag, 引用 list 的 tag 有三种方式
```{r}
j$salary
j[["salary"]]
j[[2]]
```

用单方括号引用的方式得到的是子 list
```{r}
class(j[1:2])
class(j[1])
```

list 加分支方式
```{r}
z$a <- 23
z[[4]] <- 28
z[5:7] <- c(FALSE,TRUE,TRUE)
z
c(list("Joe", 55000, T),list(5))

#返回 list 的tags
names(z)
#返回向量, 将原list的name转换为向量的name
unlist(z)

# 下面这两个不一样
# 这个得到的是 recrusive list
c(list(a=1,b=2,c=list(d=5,e=9)))
# 这个得到的是vector
c(list(a=1,b=2,c=list(d=5,e=9)),recursive=T)
```

# Data Frame
data frame 是一个 list, 该 list 每个分支都是长度相同的向量.
事实上, R 允许 data frame 的分支是其他类型, 甚至是 data frame, 这种情形极少使用.

```{r}
df <- as.data.frame(list(sname=c("n1","n2","n3"), kv=c(6,8,10)))
df
class(df)
df[df$kv >= 8,]
subset(df,kv >= 8)
```

complete.case() 函数判断哪些行是完整的, 即不包含 NA 的行.

在 data frame 中加入新列, 新加入向量长度过长会报错, 过短就 cycling.

# 函数的使用

## 函数：paste 
作用：拼接字符串
sep 是向量同位置的分隔符，collapse 是向量各分量的分隔符
```{r paste}
paste("AA", "BB", sep = ",")
paste("AA", "BB", collapse = ",")

paste("A", 1:6, sep = ",")
paste("A", 1:6, collapse = ",")

paste("A", 1:6, sep = "_", collapse = ",")
  # 函数 paste0 比 paste 少sep 参数，据说效率会高一点
paste0("A", 1:6, collapse = ",")
```

## 函数：diff
作用：做差分
这是一个 generic function, lag 表示移动几位做差值，differences表示将diff重复执行几次，所以下面两个式子等价
```{r diff}
diff(1:10, differences = 2)
diff(diff(1:10))
# 看函数自带的例子
example("diff") 
```

## 函数：sub
作用：替换
```{r sub}
gsub("a", "b", x) # 将 x 中的字符"a"都替换成字符"b"
```

## 函数: seq
```{r seq}
# 下面两个等价
seq(1, 4)
1:4
```

当 x 不是空向量时, 下面两个等价, 否则前者会执行两次, 而后者不会执行, 所以后面一种形式更好
```{r seq adv}
x <- c("a", "c")
for(i in 1:length(x)){print("1")}
for(i in seq(x)){print("1")}
x <- c()
for(i in 1:length(x)){print("1")}
for(i in seq(x)){print("1")}
```

## 函数: repeat
```{r rep}
rep(1, 5)
rep(c("a", "c"), 3)
```

# 关于 Object-Oriented
http://adv-r.had.co.nz/OO-essentials.html

R 有三个 OO 系统和一个base type，所以有四套系统
*S3* 是一种通用函数（generic function）OO, 这种面向对象系统不同于 Java, C++, C#等，这些是采用消息传递（message passing）的 OO 系统，也即是通过消息传递来调用方法（method）. S3 是通过一种特殊的函数，通用函数，来调用方法，这种 OO 系统比较随意，它没有类的形式定义（formal definition）.
S3 系统是随着 base 包被分发的.
message passing 的调用方式类似这样: canvas.drawRect("blue")
而generic function 的调用方式类似这样: drawRect(canvas, "blue")

关于 generic function，最早出现在 CLOS(Common Lisp Object System) 中，如下所述，来源[这里](http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html)

> Perhaps the biggest difference between a generic function-based system and a message-passing system is that methods don't belong to classes; they belong to the generic function, which is responsible for determining what method or methods to run in response to a particular invocation.

*S4* 和 S3 类似，有两点不同，S4 有类的形式定义来描述类的表示和继承，S4 还有特殊的帮助函数用来定义通用函数和方法. S4 有多个代码分派(dispatch), 意味着通用函数可以调用任意参数的基于类的方法.
S4 系统是随着 methods 包被分发的.


*RC(Reference Classes)* 不同于 S3 和 S4, RC 是采用消息传递的 OO, 所以方法是属于类的, 而不是属于函数. 用 $ 来区分类和方法, 调用方式如下: canvas$drawRect("blue"). RC 也是多变的, 因为他不采用 R 通常的 copy-on-modify 方式(即在修改一个对象时会先拷贝到一个新地址再做修改), 而是采用 modified in place

*base types* 内部 C 语言层级的类型, 是其他 OO 系统的基石(building blocks). 通常这些基础类型通过 C 语言操作.

参考:
1. The Art of R Programming
